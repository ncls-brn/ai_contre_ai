# pentest/run_pentest.py
import sys
import os
from pathlib import Path
import logging
from typing import Dict

# Ajouter le rÃ©pertoire parent au path
sys.path.insert(0, str(Path(__file__).parent.parent))

from security_filters import SecurityFilter
from data_security import SecureDataManager
from authentication import AuthenticationManager, JWTManager, SessionManager
from adversarial_prompts import AdversarialPromptTester
from fuzzing import InputFuzzer
from data_integrity import DataIntegrityTester, YFinanceSecurityTester
from auth_pentest import AuthenticationPentester
from mitre_attack import MITREAttackMapper
from report_generator import PentestReportGenerator
import secrets

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pentest.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class CompletePentestRunner:
    """Orchestrateur complet du pentest"""
    
    def __init__(self):
        """Initialiser le runner de pentest"""
        self.results = {}
        self.jwt_secret = os.getenv('JWT_SECRET', secrets.token_hex(32))
        
        logger.info("=" * 80)
        logger.info("ğŸ”’ PENETRATION TESTING SUITE")
        logger.info("Secure Financial Analysis Assistant")
        logger.info("=" * 80)
    
    def run_prompt_injection_tests(self) -> Dict:
        """
        ExÃ©cuter les tests d'injection de prompts
        
        Returns:
            Dict: RÃ©sultats des tests
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ“ Phase 1: PROMPT INJECTION TESTING")
        logger.info("=" * 80)
        
        try:
            security_filter = SecurityFilter()
            results = AdversarialPromptTester.run_all_tests(security_filter)
            
            logger.info(f"\nâœ… Prompt Injection Tests Completed:")
            logger.info(f"   - Total Tests: {results['total_tests']}")
            logger.info(f"   - Blocked: {results['blocked']}")
            logger.info(f"   - Successful Attacks: {results['successful_attacks']}")
            logger.info(f"   - Block Rate: {results['block_rate']:.1f}%")
            
            if results['successful_attacks'] > 0:
                logger.warning(f"\nâš ï¸  {results['successful_attacks']} ATTACKS SUCCEEDED!")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in prompt injection tests: {e}")
            return {'error': str(e)}
    
    def run_fuzzing_tests(self) -> Dict:
        """
        ExÃ©cuter les tests de fuzzing
        
        Returns:
            Dict: RÃ©sultats des tests
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ” Phase 2: INPUT FUZZING")
        logger.info("=" * 80)
        
        results = {}
        
        try:
            security_filter = SecurityFilter()
            
            # Fuzzing du ticker
            logger.info("\nğŸ“Š Testing ticker input...")
            ticker_results = InputFuzzer.fuzz_ticker_input(security_filter)
            results['ticker'] = ticker_results
            
            logger.info(f"   - Total Tests: {ticker_results['total_tests']}")
            logger.info(f"   - Block Rate: {ticker_results['block_rate']:.1f}%")
            logger.info(f"   - Vulnerabilities: {len(ticker_results['vulnerabilities'])}")
            
            # Fuzzing du message
            logger.info("\nğŸ’¬ Testing message input...")
            message_results = InputFuzzer.fuzz_message_input(security_filter)
            results['message'] = message_results
            
            logger.info(f"   - Total Tests: {message_results['total_tests']}")
            logger.info(f"   - Block Rate: {message_results['block_rate']:.1f}%")
            logger.info(f"   - Vulnerabilities: {len(message_results['vulnerabilities'])}")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in fuzzing tests: {e}")
            return {'error': str(e)}
    
    def run_data_integrity_tests(self) -> Dict:
        """
        ExÃ©cuter les tests d'intÃ©gritÃ© des donnÃ©es
        
        Returns:
            Dict: RÃ©sultats des tests
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ” Phase 3: DATA INTEGRITY TESTING")
        logger.info("=" * 80)
        
        results = {}
        
        try:
            # Test de cache poisoning
            logger.info("\nğŸ—„ï¸  Testing cache poisoning resistance...")
            cache_results = DataIntegrityTester.test_cache_poisoning()
            results['cache_poisoning'] = cache_results
            
            if cache_results.get('total_tests', 0) > 0:
                logger.info(f"   - Total Tests: {cache_results['total_tests']}")
                logger.info(f"   - Protected: {cache_results['protected']}")
                logger.info(f"   - Vulnerabilities: {len(cache_results.get('vulnerabilities', []))}")
            else:
                logger.info(f"   - {cache_results.get('note', 'No tests run')}")
            
            # Test de validation des donnÃ©es
            logger.info("\nğŸ“ˆ Testing data validation...")
            data_manager = SecureDataManager()
            validation_results = DataIntegrityTester.test_data_validation(data_manager)
            results['data_validation'] = validation_results
            
            logger.info(f"   - Total Tests: {validation_results['total_tests']}")
            logger.info(f"   - Block Rate: {validation_results['block_rate']:.1f}%")
            logger.info(f"   - Vulnerabilities: {len(validation_results.get('vulnerabilities', []))}")
            
            # Test d'injection yfinance
            logger.info("\nğŸ“Š Testing yfinance ticker injection...")
            yfinance_results = YFinanceSecurityTester.test_ticker_injection()
            results['yfinance_injection'] = yfinance_results
            
            logger.info(f"   - Total Tests: {yfinance_results['total_tests']}")
            logger.info(f"   - Block Rate: {yfinance_results['block_rate']:.1f}%")
            logger.info(f"   - Vulnerabilities: {len(yfinance_results.get('vulnerabilities', []))}")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in data integrity tests: {e}")
            return {'error': str(e)}
    
    def run_authentication_tests(self) -> Dict:
        """
        ExÃ©cuter les tests d'authentification
        
        Returns:
            Dict: RÃ©sultats des tests
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ”‘ Phase 4: AUTHENTICATION SECURITY TESTING")
        logger.info("=" * 80)
        
        results = {}
        
        try:
            auth_manager = AuthenticationManager(
                jwt_secret=self.jwt_secret,
                storage_path=".test_auth_pentest"
            )
            
            # Test de politique de mots de passe
            logger.info("\nğŸ”’ Testing password policy...")
            password_results = AuthenticationPentester.test_password_policy(auth_manager)
            results['password_policy'] = password_results
            
            logger.info(f"   - Total Tests: {password_results['total_tests']}")
            logger.info(f"   - Block Rate: {password_results['block_rate']:.1f}%")
            logger.info(f"   - Vulnerabilities: {len(password_results.get('vulnerabilities', []))}")
            
            # Test de brute force
            logger.info("\nğŸ”¨ Testing brute force protection...")
            brute_force_results = AuthenticationPentester.test_brute_force_protection(auth_manager)
            results['brute_force'] = brute_force_results
            
            if brute_force_results.get('lockout_triggered'):
                logger.info(f"   âœ… Lockout triggered after {brute_force_results['attempts_before_lockout']} attempts")
            else:
                logger.warning(f"   âš ï¸  No lockout detected after {brute_force_results['total_tests']} attempts")
            
            # Test de sÃ©curitÃ© JWT
            logger.info("\nğŸ« Testing JWT security...")
            jwt_results = AuthenticationPentester.test_jwt_security(auth_manager.jwt_manager)
            results['jwt_security'] = jwt_results
            
            logger.info(f"   - Total Tests: {jwt_results['total_tests']}")
            logger.info(f"   - Vulnerabilities: {len(jwt_results.get('vulnerabilities', []))}")
            
            # Test de bypass MFA
            logger.info("\nğŸ” Testing MFA bypass...")
            mfa_results = AuthenticationPentester.test_mfa_bypass(auth_manager)
            results['mfa_bypass'] = mfa_results
            
            logger.info(f"   - Total Tests: {mfa_results['total_tests']}")
            logger.info(f"   - Vulnerabilities: {len(mfa_results.get('vulnerabilities', []))}")
            
            # Test de sÃ©curitÃ© des sessions
            logger.info("\nğŸ­ Testing session security...")
            session_results = AuthenticationPentester.test_session_security(auth_manager.session_manager)
            results['session_security'] = session_results
            
            logger.info(f"   - Total Tests: {session_results['total_tests']}")
            logger.info(f"   - Vulnerabilities: {len(session_results.get('vulnerabilities', []))}")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in authentication tests: {e}")
            return {'error': str(e)}
        finally:
            # Nettoyer les fichiers de test
            import shutil
            try:
                shutil.rmtree(".test_auth_pentest")
            except:
                pass
    
    def run_mitre_mapping(self) -> Dict:
        """
        GÃ©nÃ©rer le mapping MITRE ATT&CK
        
        Returns:
            Dict: RÃ©sultats MITRE
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ¯ Phase 5: MITRE ATT&CK MAPPING")
        logger.info("=" * 80)
        
        try:
            coverage = MITREAttackMapper.get_coverage_report()
            
            overall = coverage['overall']
            
            logger.info(f"\nğŸ“Š Overall Coverage:")
            logger.info(f"   - Total Techniques: {overall['total_techniques']}")
            logger.info(f"   - Tested: {overall['tested']} ({overall['test_coverage']:.1f}%)")
            logger.info(f"   - Mitigated: {overall['mitigated']} ({overall['mitigation_coverage']:.1f}%)")
            
            # Techniques non testÃ©es
            untested = MITREAttackMapper.get_untested_techniques()
            if untested:
                logger.warning(f"\nâš ï¸  {len(untested)} techniques not yet tested:")
                for technique in untested[:5]:  # Afficher les 5 premiÃ¨res
                    logger.warning(f"   - {technique.id}: {technique.name}")
            
            # Techniques non mitigÃ©es
            unmitigated = MITREAttackMapper.get_unmitgated_techniques()
            if unmitigated:
                logger.warning(f"\nâš ï¸  {len(unmitigated)} techniques not yet mitigated:")
                for technique in unmitigated[:5]:
                    logger.warning(f"   - {technique.id}: {technique.name}")
            
            return coverage
            
        except Exception as e:
            logger.error(f"Error in MITRE mapping: {e}")
            return {'error': str(e)}
    
    def generate_report(self, test_results: Dict, mitre_results: Dict) -> str:
        """
        GÃ©nÃ©rer le rapport final
        
        Args:
            test_results: RÃ©sultats des tests
            mitre_results: RÃ©sultats MITRE
        
        Returns:
            str: Chemin du rapport
        """
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ“„ Phase 6: REPORT GENERATION")
        logger.info("=" * 80)
        
        try:
            # GÃ©nÃ©rer le rapport complet
            report_content = PentestReportGenerator.generate_full_report(
                test_results,
                mitre_results
            )
            
            # Sauvegarder le rapport
            report_path = PentestReportGenerator.save_report(report_content)
            
            logger.info(f"\nâœ… Report generated successfully:")
            logger.info(f"   ğŸ“ {report_path}")
            
            return report_path
            
        except Exception as e:
            logger.error(f"Error generating report: {e}")
            return None
    
    def run_complete_suite(self):
        """ExÃ©cuter la suite complÃ¨te de tests"""
        logger.info("\nğŸš€ Starting Complete Penetration Test Suite\n")
        
        # Phase 1: Prompt Injection
        self.results['prompt_injection'] = self.run_prompt_injection_tests()
        
        # Phase 2: Fuzzing
        self.results['fuzzing'] = self.run_fuzzing_tests()
        
        # Phase 3: Data Integrity
        self.results['data_integrity'] = self.run_data_integrity_tests()
        
        # Phase 4: Authentication
        self.results['authentication'] = self.run_authentication_tests()
        
        # Phase 5: MITRE Mapping
        mitre_results = self.run_mitre_mapping()
        
        # Phase 6: Generate Report
        report_path = self.generate_report(self.results, mitre_results)
        
        # Summary
        logger.info("\n" + "=" * 80)
        logger.info("ğŸ PENETRATION TEST COMPLETED")
        logger.info("=" * 80)
        
        # Compter les vulnÃ©rabilitÃ©s
        total_vulns = 0
        critical_vulns = 0
        
        for test_name, test_results in self.results.items():
            if isinstance(test_results, dict):
                if 'vulnerabilities' in test_results:
                    vulns = test_results['vulnerabilities']
                    total_vulns += len(vulns)
                    critical_vulns += sum(1 for v in vulns if v.get('severity') == 'Critical')
                
                # Pour les rÃ©sultats imbriquÃ©s (fuzzing, etc.)
                for key, value in test_results.items():
                    if isinstance(value, dict) and 'vulnerabilities' in value:
                        vulns = value['vulnerabilities']
                        total_vulns += len(vulns)
                        critical_vulns += sum(1 for v in vulns if v.get('severity') == 'Critical')
        
        logger.info(f"\nğŸ“Š Final Statistics:")
        logger.info(f"   - Total Vulnerabilities: {total_vulns}")
        logger.info(f"   - Critical: {critical_vulns}")
        logger.info(f"   - Report: {report_path}")
        
        if critical_vulns > 0:
            logger.warning(f"\nğŸ”´ {critical_vulns} CRITICAL VULNERABILITIES FOUND!")
            logger.warning("   Immediate action required!")
        elif total_vulns > 0:
            logger.warning(f"\nğŸŸ¡ {total_vulns} vulnerabilities found")
            logger.warning("   Review and remediate as appropriate")
        else:
            logger.info("\nâœ… No vulnerabilities detected - Excellent security posture!")
        
        logger.info("\n" + "=" * 80)
        
        return self.results, mitre_results, report_path


def main():
    """Point d'entrÃ©e principal"""
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                              â•‘
â•‘     ğŸ”’ PENETRATION TESTING SUITE                            â•‘
â•‘     Secure Financial Analysis Assistant                     â•‘
â•‘                                                              â•‘
â•‘     Framework: MITRE ATT&CK + OWASP Top 10 for LLM         â•‘
â•‘     Scope: Authentication, Data Integrity, API Security     â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    runner = CompletePentestRunner()
    
    try:
        results, mitre_results, report_path = runner.run_complete_suite()
        
        print("\n" + "=" * 80)
        print("âœ… Pentest completed successfully!")
        print(f"ğŸ“„ Full report available at: {report_path}")
        print("=" * 80 + "\n")
        
        return 0
        
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Pentest interrupted by user")
        return 1
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        print(f"\nâŒ Fatal error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())