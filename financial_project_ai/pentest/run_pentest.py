# pentest/run_pentest.py
import sys
import os
from pathlib import Path
import logging
from typing import Dict, List, Tuple
import argparse
from io import StringIO
from datetime import datetime

# Ajouter le rÃ©pertoire parent au path
sys.path.insert(0, str(Path(__file__).parent.parent))

from security_filters import SecurityFilter
from data_security import SecureDataManager
from authentication import AuthenticationManager, JWTManager, SessionManager
from adversarial_prompts import AdversarialPromptTester
from fuzzing import InputFuzzer
from data_integrity import DataIntegrityTester, YFinanceSecurityTester
from auth_pentest import AuthenticationPentester
from mitre_attack import MITREAttackMapper
from report_generator import PentestReportGenerator
import secrets


class ConsoleCapture:
    """Capture de la sortie console"""
    
    def __init__(self):
        self.console_output = []
        self.start_time = datetime.now()
        
    def log(self, message: str, level: str = 'INFO'):
        """
        Logger un message et le capturer
        
        Args:
            message: Message Ã  logger
            level: Niveau de log
        """
        timestamp = datetime.now().strftime('%H:%M:%S')
        formatted_msg = f"[{timestamp}] [{level}] {message}"
        self.console_output.append(formatted_msg)
        
        # Afficher aussi dans la console
        print(formatted_msg)
    
    def get_output(self) -> str:
        """
        Obtenir toute la sortie capturÃ©e
        
        Returns:
            str: Output formatÃ©
        """
        duration = datetime.now() - self.start_time
        
        header = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘             PENETRATION TEST - CONSOLE OUTPUT                â•‘
â•‘             Duration: {str(duration).split('.')[0]}                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
        return header + "\n".join(self.console_output)


# Configuration du logging avec capture
console_capture = ConsoleCapture()

# Logger personnalisÃ© qui capture tout
class CapturingHandler(logging.Handler):
    """Handler qui capture les logs"""
    
    def emit(self, record):
        msg = self.format(record)
        console_capture.console_output.append(msg)


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pentest.log'),
        logging.StreamHandler(),
        CapturingHandler()
    ]
)
logger = logging.getLogger(__name__)


class CompletePentestRunner:
    """Orchestrateur complet du pentest - Version AvancÃ©e avec Capture Console"""
    
    def __init__(self, mode: str = 'full'):
        """
        Initialiser le runner de pentest
        
        Args:
            mode: Mode d'exÃ©cution ('full', 'quick', 'advanced')
        """
        self.results = {}
        self.mode = mode
        self.jwt_secret = os.getenv('JWT_SECRET', secrets.token_hex(32))
        self.console = console_capture
        
        self.console.log("=" * 80)
        self.console.log("ğŸ”’ PENETRATION TESTING SUITE - ADVANCED VERSION", 'INFO')
        self.console.log("Secure Financial Analysis Assistant", 'INFO')
        self.console.log(f"Mode: {mode.upper()}", 'INFO')
        self.console.log("=" * 80)
    
    def run_prompt_injection_tests(self) -> Dict:
        """ExÃ©cuter les tests d'injection de prompts"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ“ Phase 1: PROMPT INJECTION TESTING", 'INFO')
        self.console.log("=" * 80)
        
        try:
            security_filter = SecurityFilter()
            results = AdversarialPromptTester.run_all_tests(security_filter)
            
            self.console.log(f"\nâœ… Prompt Injection Tests Completed:", 'INFO')
            self.console.log(f"   - Total Tests: {results['total_tests']}", 'INFO')
            self.console.log(f"   - Blocked: {results['blocked']}", 'INFO')
            self.console.log(f"   - Successful Attacks: {results['successful_attacks']}", 'INFO')
            self.console.log(f"   - Block Rate: {results['block_rate']:.1f}%", 'INFO')
            
            if results['successful_attacks'] > 0:
                self.console.log(f"\nâš ï¸  {results['successful_attacks']} ATTACKS SUCCEEDED!", 'WARNING')
            
            return results
            
        except Exception as e:
            self.console.log(f"Error in prompt injection tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_advanced_llm_attacks(self) -> Dict:
        """ExÃ©cuter les attaques LLM avancÃ©es"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ”¥ Phase 1b: ADVANCED LLM ATTACKS", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from advanced_llm_attacks import AdvancedLLMAttacker
            
            security_filter = SecurityFilter()
            
            self.console.log("\nğŸ¯ Testing advanced attack vectors...", 'INFO')
            advanced_results = AdvancedLLMAttacker.test_advanced_attacks(security_filter)
            
            self.console.log(f"\nâœ… Advanced LLM Attack Tests Completed:", 'INFO')
            self.console.log(f"   - Total Attack Categories: {advanced_results['total_attacks']}", 'INFO')
            self.console.log(f"   - Total Payloads: {advanced_results['total_payloads']}", 'INFO')
            self.console.log(f"   - Blocked: {advanced_results['blocked']}", 'INFO')
            self.console.log(f"   - Block Rate: {advanced_results['block_rate']:.1f}%", 'INFO')
            
            for category, stats in advanced_results['attack_categories'].items():
                if stats['severity'] == 'Critical' and stats['successful'] > 0:
                    self.console.log(f"   ğŸ”´ CRITICAL: {category} - {stats['successful']} attacks succeeded", 'WARNING')
            
            self.console.log("\nğŸ” Testing encoding bypass techniques...", 'INFO')
            encoding_results = AdvancedLLMAttacker.test_encoding_bypass()
            
            self.console.log(f"   - Encoding Tests: {encoding_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {encoding_results['block_rate']:.1f}%", 'INFO')
            
            return {
                'advanced_attacks': advanced_results,
                'encoding_bypass': encoding_results
            }
            
        except ImportError:
            self.console.log("Advanced LLM attack module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in advanced LLM attacks: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_chained_attacks(self) -> Dict:
        """ExÃ©cuter les tests d'attaques chaÃ®nÃ©es"""
        self.console.log("\n" + "=" * 80)
        self.console.log("â›“ï¸  Phase 1c: CHAINED ATTACK SCENARIOS", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from advanced_llm_attacks import ChainedAttackTester
            
            self.console.log("\nğŸ”— Testing authentication attack chain...", 'INFO')
            auth_chain = ChainedAttackTester.test_authentication_chain()
            
            self.console.log(f"   - Chain: {auth_chain['chain_name']}", 'INFO')
            self.console.log(f"   - Steps: {len(auth_chain['steps'])}", 'INFO')
            
            self.console.log("\nğŸ”— Testing data exfiltration chain...", 'INFO')
            exfil_chain = ChainedAttackTester.test_data_exfiltration_chain()
            
            self.console.log(f"   - Chain: {exfil_chain['chain_name']}", 'INFO')
            self.console.log(f"   - Steps: {len(exfil_chain['steps'])}", 'INFO')
            
            return {
                'authentication_chain': auth_chain,
                'exfiltration_chain': exfil_chain
            }
            
        except ImportError:
            self.console.log("Chained attack module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in chained attacks: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_fuzzing_tests(self) -> Dict:
        """ExÃ©cuter les tests de fuzzing"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ” Phase 2: INPUT FUZZING", 'INFO')
        self.console.log("=" * 80)
        
        results = {}
        
        try:
            security_filter = SecurityFilter()
            
            self.console.log("\nğŸ“Š Testing ticker input...", 'INFO')
            ticker_results = InputFuzzer.fuzz_ticker_input(security_filter)
            results['ticker'] = ticker_results
            
            self.console.log(f"   - Total Tests: {ticker_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {ticker_results['block_rate']:.1f}%", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(ticker_results['vulnerabilities'])}", 'INFO')
            
            self.console.log("\nğŸ’¬ Testing message input...", 'INFO')
            message_results = InputFuzzer.fuzz_message_input(security_filter)
            results['message'] = message_results
            
            self.console.log(f"   - Total Tests: {message_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {message_results['block_rate']:.1f}%", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(message_results['vulnerabilities'])}", 'INFO')
            
            return results
            
        except Exception as e:
            self.console.log(f"Error in fuzzing tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_data_integrity_tests(self) -> Dict:
        """ExÃ©cuter les tests d'intÃ©gritÃ© des donnÃ©es"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ” Phase 3: DATA INTEGRITY TESTING", 'INFO')
        self.console.log("=" * 80)
        
        results = {}
        
        try:
            self.console.log("\nğŸ—„ï¸  Testing cache poisoning resistance...", 'INFO')
            cache_results = DataIntegrityTester.test_cache_poisoning()
            results['cache_poisoning'] = cache_results
            
            if cache_results.get('total_tests', 0) > 0:
                self.console.log(f"   - Total Tests: {cache_results['total_tests']}", 'INFO')
                self.console.log(f"   - Protected: {cache_results['protected']}", 'INFO')
                self.console.log(f"   - Vulnerabilities: {len(cache_results.get('vulnerabilities', []))}", 'INFO')
            else:
                self.console.log(f"   - {cache_results.get('note', 'No tests run')}", 'INFO')
            
            self.console.log("\nğŸ“ˆ Testing data validation...", 'INFO')
            data_manager = SecureDataManager()
            validation_results = DataIntegrityTester.test_data_validation(data_manager)
            results['data_validation'] = validation_results
            
            self.console.log(f"   - Total Tests: {validation_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {validation_results['block_rate']:.1f}%", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(validation_results.get('vulnerabilities', []))}", 'INFO')
            
            self.console.log("\nğŸ“Š Testing yfinance ticker injection...", 'INFO')
            yfinance_results = YFinanceSecurityTester.test_ticker_injection()
            results['yfinance_injection'] = yfinance_results
            
            self.console.log(f"   - Total Tests: {yfinance_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {yfinance_results['block_rate']:.1f}%", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(yfinance_results.get('vulnerabilities', []))}", 'INFO')
            
            return results
            
        except Exception as e:
            self.console.log(f"Error in data integrity tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_authentication_tests(self) -> Dict:
        """ExÃ©cuter les tests d'authentification"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ”‘ Phase 4: AUTHENTICATION SECURITY TESTING", 'INFO')
        self.console.log("=" * 80)
        
        results = {}
        
        try:
            auth_manager = AuthenticationManager(
                jwt_secret=self.jwt_secret,
                storage_path=".test_auth_pentest"
            )
            
            self.console.log("\nğŸ”’ Testing password policy...", 'INFO')
            password_results = AuthenticationPentester.test_password_policy(auth_manager)
            results['password_policy'] = password_results
            
            self.console.log(f"   - Total Tests: {password_results['total_tests']}", 'INFO')
            self.console.log(f"   - Block Rate: {password_results['block_rate']:.1f}%", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(password_results.get('vulnerabilities', []))}", 'INFO')
            
            self.console.log("\nğŸ”¨ Testing brute force protection...", 'INFO')
            brute_force_results = AuthenticationPentester.test_brute_force_protection(auth_manager)
            results['brute_force'] = brute_force_results
            
            if brute_force_results.get('lockout_triggered'):
                self.console.log(f"   âœ… Lockout triggered after {brute_force_results['attempts_before_lockout']} attempts", 'INFO')
            else:
                self.console.log(f"   âš ï¸  No lockout detected after {brute_force_results['total_tests']} attempts", 'WARNING')
            
            self.console.log("\nğŸ« Testing JWT security...", 'INFO')
            jwt_results = AuthenticationPentester.test_jwt_security(auth_manager.jwt_manager)
            results['jwt_security'] = jwt_results
            
            self.console.log(f"   - Total Tests: {jwt_results['total_tests']}", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(jwt_results.get('vulnerabilities', []))}", 'INFO')
            
            self.console.log("\nğŸ” Testing MFA bypass...", 'INFO')
            mfa_results = AuthenticationPentester.test_mfa_bypass(auth_manager)
            results['mfa_bypass'] = mfa_results
            
            self.console.log(f"   - Total Tests: {mfa_results['total_tests']}", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(mfa_results.get('vulnerabilities', []))}", 'INFO')
            
            self.console.log("\nğŸ­ Testing session security...", 'INFO')
            session_results = AuthenticationPentester.test_session_security(auth_manager.session_manager)
            results['session_security'] = session_results
            
            self.console.log(f"   - Total Tests: {session_results['total_tests']}", 'INFO')
            self.console.log(f"   - Vulnerabilities: {len(session_results.get('vulnerabilities', []))}", 'INFO')
            
            return results
            
        except Exception as e:
            self.console.log(f"Error in authentication tests: {e}", 'ERROR')
            return {'error': str(e)}
        finally:
            import shutil
            try:
                shutil.rmtree(".test_auth_pentest")
            except:
                pass
    
    def run_performance_tests(self) -> Dict:
        """ExÃ©cuter les tests de performance et DoS"""
        self.console.log("\n" + "=" * 80)
        self.console.log("âš¡ Phase 5: PERFORMANCE & DOS TESTING", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from performance_attacks import PerformanceAttackTester, APIAbuseTester
            
            self.console.log("\nğŸ’£ Testing resource exhaustion...", 'INFO')
            resource_results = PerformanceAttackTester.test_resource_exhaustion()
            
            self.console.log(f"   - Tests defined: {len(resource_results['tests'])}", 'INFO')
            
            self.console.log("\nğŸ’¸ Testing API cost abuse...", 'INFO')
            api_abuse_results = APIAbuseTester.test_api_cost_exhaustion()
            
            self.console.log(f"   - Potential vulnerabilities: {len(api_abuse_results['vulnerabilities'])}", 'INFO')
            
            return {
                'resource_exhaustion': resource_results,
                'api_abuse': api_abuse_results
            }
            
        except ImportError:
            self.console.log("Performance attack module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in performance tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_network_security_tests(self) -> Dict:
        """ExÃ©cuter les tests de sÃ©curitÃ© rÃ©seau"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸŒ Phase 6: NETWORK SECURITY TESTING", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from network_security import NetworkSecurityTester
            
            self.console.log("\nğŸ”’ Testing TLS/SSL configuration...", 'INFO')
            tls_results = NetworkSecurityTester.test_tls_configuration()
            
            if tls_results['tls_enabled']:
                self.console.log(f"   âœ… TLS enabled: {tls_results['tls_version']}", 'INFO')
            else:
                self.console.log(f"   âš ï¸  TLS not enabled", 'WARNING')
            
            self.console.log("\nğŸ“‹ Testing HTTP security headers...", 'INFO')
            headers_results = NetworkSecurityTester.test_http_headers()
            
            self.console.log(f"   - Missing headers: {len(headers_results['missing_headers'])}", 'INFO')
            
            self.console.log("\nğŸŒ Testing CORS configuration...", 'INFO')
            cors_results = NetworkSecurityTester.test_cors_configuration()
            
            return {
                'tls_ssl': tls_results,
                'http_headers': headers_results,
                'cors': cors_results
            }
            
        except ImportError:
            self.console.log("Network security module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in network security tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_compliance_audit(self) -> Dict:
        """ExÃ©cuter l'audit de conformitÃ©"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ“‹ Phase 7: COMPLIANCE AUDIT", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from compliance_audit import ComplianceAuditor
            
            self.console.log("\nğŸ‡ªğŸ‡º GDPR Compliance Audit...", 'INFO')
            gdpr_results = ComplianceAuditor.audit_gdpr_compliance()
            
            self.console.log(f"   - Compliance Score: {gdpr_results['compliance_score']:.1f}%", 'INFO')
            self.console.log(f"   - Status: {gdpr_results['status']}", 'INFO')
            self.console.log(f"   - Actions Required: {len(gdpr_results['actions_required'])}", 'INFO')
            
            self.console.log("\nğŸ›¡ï¸  OWASP Top 10 Audit...", 'INFO')
            owasp_results = ComplianceAuditor.audit_owasp_top10()
            
            self.console.log(f"   - Framework: {owasp_results['framework']}", 'INFO')
            self.console.log(f"   - High Risk Items: {len(owasp_results['high_risk_items'])}", 'INFO')
            
            return {
                'gdpr': gdpr_results,
                'owasp': owasp_results
            }
            
        except ImportError:
            self.console.log("Compliance audit module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in compliance audit: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_integration_tests(self) -> Dict:
        """ExÃ©cuter les tests d'intÃ©gration sur l'application live"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸŒ Phase 8: LIVE APPLICATION INTEGRATION TESTS", 'INFO')
        self.console.log("=" * 80)
        
        try:
            from integration_test import LiveApplicationPentester
            
            self.console.log("\nâš ï¸  Note: This phase requires the application to be running", 'INFO')
            self.console.log("   Start with: python main.py", 'INFO')
            self.console.log("   Then run this pentest in another terminal\n", 'INFO')
            
            response = input("Is the application running? (y/n): ").strip().lower()
            
            if response != 'y':
                self.console.log("Skipping integration tests", 'INFO')
                return {'skipped': True, 'reason': 'Application not running'}
            
            pentester = LiveApplicationPentester()
            results = pentester.run_all_tests()
            
            return results
            
        except ImportError:
            self.console.log("Integration test module not found, skipping...", 'WARNING')
            return {'skipped': True}
        except Exception as e:
            self.console.log(f"Error in integration tests: {e}", 'ERROR')
            return {'error': str(e)}
    
    def run_mitre_mapping(self) -> Dict:
        """GÃ©nÃ©rer le mapping MITRE ATT&CK"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ¯ Phase 9: MITRE ATT&CK MAPPING", 'INFO')
        self.console.log("=" * 80)
        
        try:
            coverage = MITREAttackMapper.get_coverage_report()
            
            overall = coverage['overall']
            
            self.console.log(f"\nğŸ“Š Overall Coverage:", 'INFO')
            self.console.log(f"   - Total Techniques: {overall['total_techniques']}", 'INFO')
            self.console.log(f"   - Tested: {overall['tested']} ({overall['test_coverage']:.1f}%)", 'INFO')
            self.console.log(f"   - Mitigated: {overall['mitigated']} ({overall['mitigation_coverage']:.1f}%)", 'INFO')
            
            untested = MITREAttackMapper.get_untested_techniques()
            if untested:
                self.console.log(f"\nâš ï¸  {len(untested)} techniques not yet tested:", 'WARNING')
                for technique in untested[:5]:
                    self.console.log(f"   - {technique.id}: {technique.name}", 'WARNING')
            
            unmitigated = MITREAttackMapper.get_unmitgated_techniques()
            if unmitigated:
                self.console.log(f"\nâš ï¸  {len(unmitigated)} techniques not yet mitigated:", 'WARNING')
                for technique in unmitigated[:5]:
                    self.console.log(f"   - {technique.id}: {technique.name}", 'WARNING')
            
            return coverage
            
        except Exception as e:
            self.console.log(f"Error in MITRE mapping: {e}", 'ERROR')
            return {'error': str(e)}
    
    def generate_report(self, test_results: Dict, mitre_results: Dict) -> Tuple[str, str]:
        """
        GÃ©nÃ©rer les rapports finaux (MD + JSON)
        
        Args:
            test_results: RÃ©sultats des tests
            mitre_results: RÃ©sultats MITRE
        
        Returns:
            Tuple[str, str]: Chemins des rapports (MD, JSON)
        """
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ“„ Phase 10: REPORT GENERATION", 'INFO')
        self.console.log("=" * 80)
        
        try:
            # GÃ©nÃ©rer le contenu Markdown
            self.console.log("\nğŸ“ Generating Markdown report...", 'INFO')
            markdown_content = PentestReportGenerator.generate_full_report_with_console(
                test_results,
                mitre_results,
                self.console.get_output()
            )
            
            # GÃ©nÃ©rer les donnÃ©es JSON
            self.console.log("ğŸ“Š Generating JSON report...", 'INFO')
            json_data = PentestReportGenerator.generate_json_report(
                test_results,
                mitre_results,
                self.console.get_output()
            )
            
            # Sauvegarder les deux formats
            self.console.log("ğŸ’¾ Saving reports...", 'INFO')
            md_path, json_path = PentestReportGenerator.save_reports(
                markdown_content,
                json_data
            )
            
            self.console.log(f"\nâœ… Reports generated successfully:", 'INFO')
            self.console.log(f"   ğŸ“„ Markdown: {md_path}", 'INFO')
            self.console.log(f"   ğŸ“Š JSON: {json_path}", 'INFO')
            
            return md_path, json_path
            
        except Exception as e:
            self.console.log(f"Error generating reports: {e}", 'ERROR')
            return None, None
    
    def run_complete_suite(self):
        """ExÃ©cuter la suite complÃ¨te de tests selon le mode"""
        self.console.log(f"\nğŸš€ Starting {self.mode.upper()} Penetration Test Suite\n", 'INFO')
        
        # Phase 1
        self.results['prompt_injection'] = self.run_prompt_injection_tests()
        
        # Phase 1b & 1c (si full ou advanced)
        if self.mode in ['full', 'advanced']:
            self.results['advanced_llm'] = self.run_advanced_llm_attacks()
            self.results['chained_attacks'] = self.run_chained_attacks()
        
        # Phase 2
        self.results['fuzzing'] = self.run_fuzzing_tests()
        
        # Phase 3
        self.results['data_integrity'] = self.run_data_integrity_tests()
        
        # Phase 4
        self.results['authentication'] = self.run_authentication_tests()
        
        # Phases 5-8 (si full ou advanced)
        if self.mode in ['full', 'advanced']:
            self.results['performance'] = self.run_performance_tests()
            self.results['network_security'] = self.run_network_security_tests()
            self.results['compliance'] = self.run_compliance_audit()
            self.results['integration'] = self.run_integration_tests()
        
        # Phase 9
        mitre_results = self.run_mitre_mapping()
        
        # Phase 10 avec console output (MD + JSON)
        md_path, json_path = self.generate_report(self.results, mitre_results)
        
        # Summary
        self._print_summary(md_path, json_path)
        
        return self.results, mitre_results, md_path, json_path
    
    def _print_summary(self, md_path: str, json_path: str):
        """Afficher le rÃ©sumÃ© final"""
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ PENETRATION TEST COMPLETED", 'INFO')
        self.console.log("=" * 80)
        
        # Compter vulnÃ©rabilitÃ©s
        total_vulns = 0
        critical_vulns = 0
        high_vulns = 0
        medium_vulns = 0
        
        def count_vulns(data):
            nonlocal total_vulns, critical_vulns, high_vulns, medium_vulns
            if isinstance(data, dict):
                if 'vulnerabilities' in data:
                    vulns = data['vulnerabilities']
                    total_vulns += len(vulns)
                    for v in vulns:
                        severity = v.get('severity', 'Medium')
                        if severity == 'Critical':
                            critical_vulns += 1
                        elif severity == 'High':
                            high_vulns += 1
                        elif severity == 'Medium':
                            medium_vulns += 1
                for value in data.values():
                    count_vulns(value)
            elif isinstance(data, list):
                for item in data:
                    count_vulns(item)
        
        count_vulns(self.results)
        
        self.console.log(f"\nğŸ“Š Final Statistics:", 'INFO')
        self.console.log(f"   - Mode: {self.mode.upper()}", 'INFO')
        self.console.log(f"   - Test Phases: {len(self.results)}", 'INFO')
        self.console.log(f"   - Total Vulnerabilities: {total_vulns}", 'INFO')
        self.console.log(f"   - ğŸ”´ Critical: {critical_vulns}", 'INFO')
        self.console.log(f"   - ğŸŸ  High: {high_vulns}", 'INFO')
        self.console.log(f"   - ğŸŸ¡ Medium: {medium_vulns}", 'INFO')
        self.console.log(f"   - Markdown Report: {md_path}", 'INFO')
        self.console.log(f"   - JSON Report: {json_path}", 'INFO')
        
        if critical_vulns > 0:
            self.console.log(f"\nğŸ”´ {critical_vulns} CRITICAL VULNERABILITIES FOUND!", 'WARNING')
            self.console.log("   âš ï¸  IMMEDIATE ACTION REQUIRED!", 'WARNING')
        elif high_vulns > 0:
            self.console.log(f"\nğŸŸ  {high_vulns} HIGH-SEVERITY vulnerabilities found", 'WARNING')
            self.console.log("   Action recommended within 7 days", 'WARNING')
        elif total_vulns > 0:
            self.console.log(f"\nğŸŸ¡ {total_vulns} vulnerabilities found", 'INFO')
            self.console.log("   Review and remediate as appropriate", 'INFO')
        else:
            self.console.log("\nâœ… No vulnerabilities detected - Excellent security posture!", 'INFO')
        
        self.console.log("\n" + "=" * 80)


def main():
    """Point d'entrÃ©e principal"""
    parser = argparse.ArgumentParser(
        description='Advanced Penetration Testing Suite with Console Capture and JSON/MD Reports',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Modes:
  quick    - Fast scan (basic tests only) - ~5 minutes
  full     - Complete scan (all tests) - ~15-30 minutes  
  advanced - Full scan + advanced attacks - ~30-60 minutes

Examples:
  python run_pentest.py                    # Full mode (default)
  python run_pentest.py --mode quick       # Quick scan
  python run_pentest.py --mode advanced    # Advanced scan
        """
    )
    
    parser.add_argument(
        '--mode',
        choices=['quick', 'full', 'advanced'],
        default='full',
        help='Pentest mode (default: full)'
    )
    
    args = parser.parse_args()
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                              â•‘
â•‘     ğŸ”’ PENETRATION TESTING SUITE - ADVANCED                 â•‘
â•‘     Complete Console Output + JSON/MD Reports               â•‘
â•‘                                                              â•‘
â•‘     Framework: MITRE ATT&CK + OWASP Top 10 + LLM Security  â•‘
â•‘     Coverage: Auth, Data, Network, Performance, Compliance  â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    runner = CompletePentestRunner(mode=args.mode)
    
    try:
        results, mitre_results, md_path, json_path = runner.run_complete_suite()
        
        print("\n" + "=" * 80)
        print("âœ… Pentest completed successfully!")
        print(f"ğŸ“„ Markdown report: {md_path}")
        print(f"ğŸ“Š JSON report: {json_path}")
        print("=" * 80 + "\n")
        
        return 0
        
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Pentest interrupted by user")
        return 1
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        print(f"\nâŒ Fatal error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())