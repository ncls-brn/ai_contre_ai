# pentest/report_generator.py
from datetime import datetime
from typing import Dict, List
import json
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


class PentestReportGenerator:
    """G√©n√©rateur de rapports de pentesting"""
    
    @staticmethod
    def generate_executive_summary(results: Dict) -> str:
        """
        G√©n√©rer un r√©sum√© ex√©cutif
        
        Args:
            results: R√©sultats complets du pentest
        
        Returns:
            str: R√©sum√© ex√©cutif en markdown
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Calculer les statistiques globales
        total_vulnerabilities = 0
        critical_count = 0
        high_count = 0
        medium_count = 0
        low_count = 0
        
        for test_results in results.values():
            if 'vulnerabilities' in test_results:
                for vuln in test_results['vulnerabilities']:
                    total_vulnerabilities += 1
                    severity = vuln.get('severity', 'Medium')
                    
                    if severity == 'Critical':
                        critical_count += 1
                    elif severity == 'High':
                        high_count += 1
                    elif severity == 'Medium':
                        medium_count += 1
                    else:
                        low_count += 1
        
        report = f"""# üîí Penetration Testing Report
## Secure Financial Analysis Assistant

**Generated:** {timestamp}
**Test Type:** Comprehensive Security Assessment
**Scope:** LLM Security, Authentication, Data Integrity, API Security

---

## Executive Summary

This penetration test was conducted on the Secure Financial Analysis Assistant application,
focusing on security controls specific to AI/LLM systems, authentication mechanisms,
data integrity, and API security.

### Key Findings

- **Total Vulnerabilities Found:** {total_vulnerabilities}
  - üî¥ Critical: {critical_count}
  - üü† High: {high_count}
  - üü° Medium: {medium_count}
  - üü¢ Low: {low_count}

### Security Posture

"""
        
        if total_vulnerabilities == 0:
            report += "‚úÖ **Excellent** - No vulnerabilities detected\n\n"
        elif critical_count > 0:
            report += f"üî¥ **Critical** - {critical_count} critical vulnerabilities require immediate attention\n\n"
        elif high_count > 0:
            report += f"üü† **High Risk** - {high_count} high-severity vulnerabilities identified\n\n"
        else:
            report += f"üü° **Moderate** - {total_vulnerabilities} vulnerabilities to address\n\n"
        
        return report
    
    @staticmethod
    def generate_technical_findings(results: Dict) -> str:
        """
        G√©n√©rer les r√©sultats techniques d√©taill√©s
        
        Args:
            results: R√©sultats complets du pentest
        
        Returns:
            str: R√©sultats techniques en markdown
        """
        report = "## Technical Findings\n\n"
        
        # 1. Prompt Injection Tests
        if 'prompt_injection' in results:
            report += "### 1. Prompt Injection Testing\n\n"
            pi_results = results['prompt_injection']
            
            report += f"- **Total Tests:** {pi_results.get('total_tests', 0)}\n"
            report += f"- **Blocked Attacks:** {pi_results.get('blocked', 0)}\n"
            report += f"- **Successful Attacks:** {pi_results.get('successful_attacks', 0)}\n"
            report += f"- **Block Rate:** {pi_results.get('block_rate', 0):.1f}%\n\n"
            
            if pi_results.get('tests'):
                report += "#### Failed Tests (Security Issues)\n\n"
                for test in pi_results['tests']:
                    if test['status'] == 'FAIL':
                        report += f"- ‚ùå **{test['name']}** ({test['severity']})\n"
                        report += f"  - Type: {test['type']}\n"
                        report += f"  - Reason: {test['reason']}\n\n"
        
        # 2. Fuzzing Tests
        if 'fuzzing' in results:
            report += "### 2. Input Fuzzing\n\n"
            fuzz_results = results['fuzzing']
            
            if 'ticker' in fuzz_results:
                report += "#### Ticker Input Fuzzing\n\n"
                ticker_fuzz = fuzz_results['ticker']
                report += f"- **Total Tests:** {ticker_fuzz.get('total_tests', 0)}\n"
                report += f"- **Block Rate:** {ticker_fuzz.get('block_rate', 0):.1f}%\n\n"
                
                if ticker_fuzz.get('vulnerabilities'):
                    report += "**Vulnerabilities Found:**\n\n"
                    for vuln in ticker_fuzz['vulnerabilities']:
                        report += f"- {vuln['type']}: `{vuln['input']}`\n"
                    report += "\n"
        
        # 3. Data Integrity Tests
        if 'data_integrity' in results:
            report += "### 3. Data Integrity Testing\n\n"
            di_results = results['data_integrity']
            
            if di_results.get('vulnerabilities'):
                report += "**Vulnerabilities Found:**\n\n"
                for vuln in di_results['vulnerabilities']:
                    report += f"- **{vuln['type']}** ({vuln.get('severity', 'Medium')})\n"
                    report += f"  - {vuln.get('description', 'No description')}\n\n"
            else:
                report += "‚úÖ No data integrity issues found\n\n"
        
        # 4. Authentication Tests
        if 'authentication' in results:
            report += "### 4. Authentication Security\n\n"
            auth_results = results['authentication']
            
            if 'password_policy' in auth_results:
                pp = auth_results['password_policy']
                report += f"#### Password Policy Testing\n\n"
                report += f"- **Block Rate:** {pp.get('block_rate', 0):.1f}%\n"
                report += f"- **Weak Passwords Blocked:** {pp.get('blocked', 0)}/{pp.get('total_tests', 0)}\n\n"
            
            if 'brute_force' in auth_results:
                bf = auth_results['brute_force']
                report += f"#### Brute Force Protection\n\n"
                
                if bf.get('lockout_triggered'):
                    report += f"‚úÖ Account lockout triggered after {bf.get('attempts_before_lockout', 0)} attempts\n\n"
                else:
                    report += f"‚ùå No lockout detected after {bf.get('total_tests', 0)} attempts\n\n"
            
            if 'jwt_security' in auth_results:
                jwt = auth_results['jwt_security']
                report += f"#### JWT Security\n\n"
                
                if jwt.get('vulnerabilities'):
                    for vuln in jwt['vulnerabilities']:
                        report += f"- ‚ùå **{vuln['type']}** ({vuln['severity']})\n"
                        report += f"  - {vuln['description']}\n\n"
                else:
                    report += "‚úÖ No JWT vulnerabilities found\n\n"
        
        return report
    
    @staticmethod
    def generate_mitre_analysis(mitre_results: Dict) -> str:
        """
        G√©n√©rer l'analyse MITRE ATT&CK
        
        Args:
            mitre_results: R√©sultats MITRE
        
        Returns:
            str: Analyse MITRE en markdown
        """
        report = "## MITRE ATT&CK Coverage\n\n"
        
        overall = mitre_results.get('overall', {})
        
        report += f"### Overall Coverage\n\n"
        report += f"- **Total Techniques Mapped:** {overall.get('total_techniques', 0)}\n"
        report += f"- **Tested:** {overall.get('tested', 0)} ({overall.get('test_coverage', 0):.1f}%)\n"
        report += f"- **Mitigated:** {overall.get('mitigated', 0)} ({overall.get('mitigation_coverage', 0):.1f}%)\n\n"
        
        tactics = mitre_results.get('tactics', {})
        
        report += "### Coverage by Tactic\n\n"
        report += "| Tactic | Total | Tested | Mitigated | Test Coverage | Mitigation Coverage |\n"
        report += "|--------|-------|--------|-----------|---------------|---------------------|\n"
        
        for tactic_name, tactic_data in tactics.items():
            report += f"| {tactic_name} | {tactic_data['total']} | {tactic_data['tested']} | {tactic_data['mitigated']} | {tactic_data['test_coverage']:.0f}% | {tactic_data['mitigation_coverage']:.0f}% |\n"
        
        report += "\n"
        
        return report
    
    @staticmethod
    def generate_recommendations(results: Dict) -> str:
        """
        G√©n√©rer les recommandations
        
        Args:
            results: R√©sultats complets du pentest
        
        Returns:
            str: Recommandations en markdown
        """
        report = "## Recommendations\n\n"
        
        recommendations = []
        
        # Analyser les r√©sultats pour g√©n√©rer des recommandations
        for test_name, test_results in results.items():
            if 'vulnerabilities' in test_results and test_results['vulnerabilities']:
                for vuln in test_results['vulnerabilities']:
                    severity = vuln.get('severity', 'Medium')
                    vuln_type = vuln.get('type', 'unknown')
                    
                    # Recommandations sp√©cifiques par type
                    if 'prompt_injection' in vuln_type or 'jailbreak' in vuln_type:
                        recommendations.append({
                            'priority': 'Critical',
                            'title': 'Strengthen Prompt Injection Detection',
                            'description': 'Implement additional layers of prompt injection detection using libraries like garak or guardrails.',
                            'impact': 'Prevents unauthorized system access and data leakage'
                        })
                    
                    elif 'cache' in vuln_type:
                        recommendations.append({
                            'priority': 'High',
                            'title': 'Implement HMAC Signing for Cache',
                            'description': 'Sign all cache files with HMAC-SHA256 to detect tampering.',
                            'impact': 'Prevents manipulation of financial data'
                        })
                    
                    elif 'jwt' in vuln_type or 'token' in vuln_type:
                        recommendations.append({
                            'priority': 'Critical',
                            'title': 'Enhance JWT Security',
                            'description': 'Use longer secret keys (64+ chars), implement token refresh rotation, consider server-side sessions.',
                            'impact': 'Prevents session hijacking and token manipulation'
                        })
                    
                    elif 'mfa' in vuln_type:
                        recommendations.append({
                            'priority': 'Critical',
                            'title': 'Enforce MFA Properly',
                            'description': 'Ensure MFA cannot be bypassed and invalid codes are rejected.',
                            'impact': 'Strengthens account security'
                        })
        
        # D√©duplication
        unique_recs = {}
        for rec in recommendations:
            if rec['title'] not in unique_recs:
                unique_recs[rec['title']] = rec
        
        # Trier par priorit√©
        priority_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}
        sorted_recs = sorted(
            unique_recs.values(),
            key=lambda x: priority_order.get(x['priority'], 999)
        )
        
        # G√©n√©rer la liste
        for i, rec in enumerate(sorted_recs, 1):
            priority_emoji = {
                'Critical': 'üî¥',
                'High': 'üü†',
                'Medium': 'üü°',
                'Low': 'üü¢'
            }
            
            emoji = priority_emoji.get(rec['priority'], '‚ö™')
            
            report += f"### {i}. {emoji} {rec['title']} ({rec['priority']})\n\n"
            report += f"**Description:** {rec['description']}\n\n"
            report += f"**Impact:** {rec['impact']}\n\n"
        
        # Recommandations g√©n√©rales
        report += "### General Security Improvements\n\n"
        report += "1. **Regular Security Audits**\n"
        report += "   - Conduct monthly Red Team/Blue Team exercises\n"
        report += "   - Implement continuous security monitoring\n\n"
        
        report += "2. **Dependency Management**\n"
        report += "   - Keep all dependencies updated\n"
        report += "   - Use tools like Dependabot or Snyk\n\n"
        
        report += "3. **Logging and Monitoring**\n"
        report += "   - Implement comprehensive audit logging\n"
        report += "   - Set up alerts for suspicious activities\n\n"
        
        report += "4. **Incident Response**\n"
        report += "   - Develop incident response procedures\n"
        report += "   - Conduct regular drills\n\n"
        
        return report
    
    @staticmethod
    def save_report(report_content: str, output_dir: str = "pentest_reports"):
        """
        Sauvegarder le rapport
        
        Args:
            report_content: Contenu du rapport
            output_dir: R√©pertoire de sortie
        """
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"pentest_report_{timestamp}.md"
        
        filepath = output_path / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        logger.info(f"Report saved to: {filepath}")
        
        return str(filepath)
    
    @classmethod
    def generate_full_report(cls, results: Dict, mitre_results: Dict) -> str:
        """
        G√©n√©rer le rapport complet
        
        Args:
            results: R√©sultats des tests
            mitre_results: R√©sultats MITRE
        
        Returns:
            str: Rapport complet en markdown
        """
        report = cls.generate_executive_summary(results)
        report += "\n---\n\n"
        report += cls.generate_technical_findings(results)
        report += "\n---\n\n"
        report += cls.generate_mitre_analysis(mitre_results)
        report += "\n---\n\n"
        report += cls.generate_recommendations(results)
        
        return report