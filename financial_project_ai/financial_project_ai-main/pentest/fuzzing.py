# pentest/fuzzing.py
import string
import random
from typing import List, Dict
import logging

logger = logging.getLogger(__name__)


class InputFuzzer:
    """Fuzzer pour tester la robustesse des entrées"""
    
    # Caractères spéciaux dangereux
    SPECIAL_CHARS = [
        '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', 
        '-', '_', '=', '+', '[', ']', '{', '}', '\\', '|',
        ';', ':', "'", '"', ',', '.', '<', '>', '/', '?',
        '`', '~'
    ]
    
    # Payloads SQL injection
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "'; DROP TABLE users--",
        "1' UNION SELECT * FROM users--",
        "admin'--",
        "' OR 1=1--",
    ]
    
    # Payloads XSS
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg/onload=alert('XSS')>",
        "';alert('XSS');//",
    ]
    
    # Payloads path traversal
    PATH_TRAVERSAL_PAYLOADS = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
    ]
    
    # Payloads command injection
    COMMAND_INJECTION_PAYLOADS = [
        "; ls -la",
        "| cat /etc/passwd",
        "`whoami`",
        "$(ls -la)",
        "&& dir",
    ]
    
    @staticmethod
    def fuzz_ticker_input(validator) -> Dict[str, any]:
        """
        Fuzzer pour le champ ticker
        
        Args:
            validator: Instance de SecurityFilter
        
        Returns:
            Dict: Résultats du fuzzing
        """
        results = {
            'total_tests': 0,
            'blocked': 0,
            'vulnerabilities': []
        }
        
        # Test 1: Caractères spéciaux
        for char in InputFuzzer.SPECIAL_CHARS:
            test_input = f"AAPL{char}"
            is_valid, error = validator.validate_ticker(test_input)
            
            results['total_tests'] += 1
            if not is_valid:
                results['blocked'] += 1
            else:
                results['vulnerabilities'].append({
                    'input': test_input,
                    'type': 'special_char_bypass'
                })
        
        # Test 2: SQL Injection
        for payload in InputFuzzer.SQL_PAYLOADS:
            is_valid, error = validator.validate_ticker(payload)
            
            results['total_tests'] += 1
            if not is_valid:
                results['blocked'] += 1
            else:
                results['vulnerabilities'].append({
                    'input': payload,
                    'type': 'sql_injection'
                })
        
        # Test 3: Path Traversal
        for payload in InputFuzzer.PATH_TRAVERSAL_PAYLOADS:
            is_valid, error = validator.validate_ticker(payload)
            
            results['total_tests'] += 1
            if not is_valid:
                results['blocked'] += 1
            else:
                results['vulnerabilities'].append({
                    'input': payload,
                    'type': 'path_traversal'
                })
        
        # Test 4: Command Injection
        for payload in InputFuzzer.COMMAND_INJECTION_PAYLOADS:
            is_valid, error = validator.validate_ticker(payload)
            
            results['total_tests'] += 1
            if not is_valid:
                results['blocked'] += 1
            else:
                results['vulnerabilities'].append({
                    'input': payload,
                    'type': 'command_injection'
                })
        
        # Test 5: Longueur excessive
        long_input = "A" * 1000
        is_valid, error = validator.validate_ticker(long_input)
        
        results['total_tests'] += 1
        if not is_valid:
            results['blocked'] += 1
        else:
            results['vulnerabilities'].append({
                'input': f"{long_input[:50]}...",
                'type': 'buffer_overflow'
            })
        
        # Test 6: Caractères null
        null_input = "AAPL\x00"
        is_valid, error = validator.validate_ticker(null_input)
        
        results['total_tests'] += 1
        if not is_valid:
            results['blocked'] += 1
        else:
            results['vulnerabilities'].append({
                'input': null_input,
                'type': 'null_byte_injection'
            })
        
        results['block_rate'] = (results['blocked'] / results['total_tests']) * 100
        
        return results
    
    @staticmethod
    def fuzz_message_input(validator) -> Dict[str, any]:
        """
        Fuzzer pour le champ message
        
        Args:
            validator: Instance de SecurityFilter
        
        Returns:
            Dict: Résultats du fuzzing
        """
        results = {
            'total_tests': 0,
            'blocked': 0,
            'vulnerabilities': []
        }
        
        # Test XSS
        for payload in InputFuzzer.XSS_PAYLOADS:
            is_safe, cleaned = validator.sanitize_input(payload, "message")
            
            results['total_tests'] += 1
            if not is_safe or payload not in cleaned:
                results['blocked'] += 1
            else:
                results['vulnerabilities'].append({
                    'input': payload,
                    'type': 'xss'
                })
        
        # Test caractères de contrôle
        for i in range(32):
            if i not in [9, 10, 13]:  # Tab, LF, CR autorisés
                test_input = f"test{chr(i)}message"
                is_safe, cleaned = validator.sanitize_input(test_input, "message")
                
                results['total_tests'] += 1
                if not is_safe:
                    results['blocked'] += 1
                else:
                    results['vulnerabilities'].append({
                        'input': repr(test_input),
                        'type': 'control_char'
                    })
        
        results['block_rate'] = (results['blocked'] / results['total_tests']) * 100
        
        return results
    
    @staticmethod
    def generate_random_payloads(count: int = 100) -> List[str]:
        """
        Générer des payloads aléatoires pour fuzzing
        
        Args:
            count: Nombre de payloads à générer
        
        Returns:
            List[str]: Liste de payloads
        """
        payloads = []
        
        for _ in range(count):
            # Longueur aléatoire
            length = random.randint(1, 1000)
            
            # Type de payload aléatoire
            payload_type = random.choice(['printable', 'special', 'mixed', 'binary'])
            
            if payload_type == 'printable':
                payload = ''.join(random.choices(string.printable, k=length))
            elif payload_type == 'special':
                payload = ''.join(random.choices(InputFuzzer.SPECIAL_CHARS, k=length))
            elif payload_type == 'mixed':
                chars = string.ascii_letters + string.digits + ''.join(InputFuzzer.SPECIAL_CHARS)
                payload = ''.join(random.choices(chars, k=length))
            else:  # binary
                payload = ''.join(chr(random.randint(0, 255)) for _ in range(min(length, 100)))
            
            payloads.append(payload)
        
        return payloads