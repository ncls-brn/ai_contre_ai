# pentest/run_pentest.py
import sys
import os
import logging
import argparse
import secrets
import shutil
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, Tuple

# ---------------------------------------------------------------------
# Path setup (robuste quel que soit le rÃ©pertoire courant)
# ---------------------------------------------------------------------
THIS_FILE = Path(__file__).resolve()
PENTEST_DIR = THIS_FILE.parent              # .../pentest
PROJECT_ROOT = PENTEST_DIR.parent           # .../financial_project_ai-main

# Importer modules projet (security_filters.py, data_security.py, etc.)
sys.path.insert(0, str(PROJECT_ROOT))
# Importer modules pentest (adversarial_prompts.py, fuzzing.py, etc.)
sys.path.insert(0, str(PENTEST_DIR))

# ---------------------------------------------------------------------
# Imports projet + pentest
# ---------------------------------------------------------------------
from security_filters import SecurityFilter
from data_security import SecureDataManager
from authentication import AuthenticationManager

from adversarial_prompts import AdversarialPromptTester
from fuzzing import InputFuzzer
from data_integrity import DataIntegrityTester, YFinanceSecurityTester
from auth_pentest import AuthenticationPentester
from mitre_attack import MITREAttackMapper
from report_generator import PentestReportGenerator


# ---------------------------------------------------------------------
# Console capture
# ---------------------------------------------------------------------
class ConsoleCapture:
    def __init__(self):
        self.console_output = []
        self.start_time = datetime.now()

    def log(self, message: str, level: str = "INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted = f"[{timestamp}] [{level}] {message}"
        self.console_output.append(formatted)
        print(formatted)

    def get_output(self) -> str:
        duration = datetime.now() - self.start_time
        header = (
            "\n"
            "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
            "â•‘             PENETRATION TEST - CONSOLE OUTPUT                â•‘\n"
            f"â•‘             Duration: {str(duration).split('.')[0]:<43}â•‘\n"
            "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
        )
        return header + "\n".join(self.console_output)


console_capture = ConsoleCapture()


class CapturingHandler(logging.Handler):
    def emit(self, record):
        msg = self.format(record)
        console_capture.console_output.append(msg)


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("pentest.log"),
        logging.StreamHandler(),
        CapturingHandler(),
    ],
)
logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------
# Runner
# ---------------------------------------------------------------------
class CompletePentestRunner:
    def __init__(self, mode: str = "full", interactive: bool = False):
        self.results: Dict = {}
        self.mode = mode
        self.interactive = interactive
        self.jwt_secret = os.getenv("JWT_SECRET", secrets.token_hex(32))
        self.console = console_capture

        self.console.log("=" * 80)
        self.console.log("ğŸ”’ PENETRATION TESTING SUITE", "INFO")
        self.console.log(f"Mode: {mode.upper()}", "INFO")
        self.console.log(f"Interactive: {interactive}", "INFO")
        self.console.log("=" * 80)

    def run_prompt_injection_tests(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ“ Phase 1: PROMPT INJECTION TESTING", "INFO")
        self.console.log("=" * 80)

        try:
            # Dans ton app, SecurityFilter est gÃ©nÃ©ralement utilisÃ© en statique
            results = AdversarialPromptTester.run_all_tests(SecurityFilter)

            self.console.log("\nâœ… Prompt Injection Tests Completed:", "INFO")
            self.console.log(f"   - Total Tests: {results.get('total_tests', 0)}", "INFO")
            self.console.log(f"   - Blocked: {results.get('blocked', 0)}", "INFO")
            self.console.log(f"   - Successful Attacks: {results.get('successful_attacks', 0)}", "INFO")
            if "block_rate" in results:
                self.console.log(f"   - Block Rate: {results['block_rate']:.1f}%", "INFO")

            if results.get("successful_attacks", 0) > 0:
                self.console.log("âš ï¸  Some prompt injection payloads bypassed filters", "WARNING")

            return results

        except Exception as e:
            self.console.log(f"Error in prompt injection tests: {e}", "ERROR")
            return {"error": str(e)}

    def run_fuzzing_tests(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ” Phase 2: INPUT FUZZING", "INFO")
        self.console.log("=" * 80)

        try:
            results = {
                "ticker": InputFuzzer.fuzz_ticker_input(SecurityFilter),
                "message": InputFuzzer.fuzz_message_input(SecurityFilter),
            }
            return results
        except Exception as e:
            self.console.log(f"Error in fuzzing tests: {e}", "ERROR")
            return {"error": str(e)}

    def run_data_integrity_tests(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ” Phase 3: DATA INTEGRITY TESTING", "INFO")
        self.console.log("=" * 80)

        try:
            results: Dict = {}

            results["cache_poisoning"] = DataIntegrityTester.test_cache_poisoning()

            data_manager = SecureDataManager()
            results["data_validation"] = DataIntegrityTester.test_data_validation(data_manager)

            results["yfinance_injection"] = YFinanceSecurityTester.test_ticker_injection()

            return results

        except Exception as e:
            self.console.log(f"Error in data integrity tests: {e}", "ERROR")
            return {"error": str(e)}

    def run_authentication_tests(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ”‘ Phase 4: AUTHENTICATION SECURITY TESTING", "INFO")
        self.console.log("=" * 80)

        storage_path = ".test_auth_pentest"
        try:
            auth_manager = AuthenticationManager(jwt_secret=self.jwt_secret, storage_path=storage_path)

            results = {
                "password_policy": AuthenticationPentester.test_password_policy(auth_manager),
                "brute_force": AuthenticationPentester.test_brute_force_protection(auth_manager),
                "jwt_security": AuthenticationPentester.test_jwt_security(auth_manager.jwt_manager),
                "mfa_bypass": AuthenticationPentester.test_mfa_bypass(auth_manager),
                "session_security": AuthenticationPentester.test_session_security(auth_manager.session_manager),
            }
            return results

        except Exception as e:
            self.console.log(f"Error in authentication tests: {e}", "ERROR")
            return {"error": str(e)}

        finally:
            try:
                shutil.rmtree(storage_path)
            except Exception:
                pass

    def run_integration_tests(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸŒ Phase: LIVE APPLICATION INTEGRATION TESTS", "INFO")
        self.console.log("=" * 80)

        # Ne jamais bloquer en quick/full CI
        if not self.interactive:
            self.console.log("Skipping integration tests (non-interactive)", "INFO")
            return {"skipped": True, "reason": "non_interactive"}

        try:
            from integration_test import LiveApplicationPentester

            response = input("Is the application running? (y/n): ").strip().lower()
            if response != "y":
                return {"skipped": True, "reason": "Application not running"}

            return LiveApplicationPentester().run_all_tests()

        except ImportError:
            self.console.log("Integration test module not found, skipping...", "WARNING")
            return {"skipped": True}
        except Exception as e:
            self.console.log(f"Error in integration tests: {e}", "ERROR")
            return {"error": str(e)}

    def run_mitre_mapping(self) -> Dict:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ¯ Phase: MITRE ATT&CK MAPPING", "INFO")
        self.console.log("=" * 80)

        try:
            return MITREAttackMapper.get_coverage_report()
        except Exception as e:
            self.console.log(f"Error in MITRE mapping: {e}", "ERROR")
            return {"error": str(e)}

    def generate_report(self, test_results: Dict, mitre_results: Dict) -> Tuple[Optional[str], Optional[str]]:
        self.console.log("\n" + "=" * 80)
        self.console.log("ğŸ“„ Phase: REPORT GENERATION", "INFO")
        self.console.log("=" * 80)

        try:
            md = PentestReportGenerator.generate_full_report_with_console(
                test_results, mitre_results, self.console.get_output()
            )
            js = PentestReportGenerator.generate_json_report(
                test_results, mitre_results, self.console.get_output()
            )
            return PentestReportGenerator.save_reports(md, js)
        except Exception as e:
            self.console.log(f"Error generating reports: {e}", "ERROR")
            return None, None

    def run_complete_suite(self):
        self.console.log(f"\nğŸš€ Starting {self.mode.upper()} Penetration Test Suite\n", "INFO")

        self.results["prompt_injection"] = self.run_prompt_injection_tests()
        self.results["fuzzing"] = self.run_fuzzing_tests()
        self.results["data_integrity"] = self.run_data_integrity_tests()
        self.results["authentication"] = self.run_authentication_tests()

        # En quick mode, on saute les phases lourdes
        if self.mode in ["full", "advanced"]:
            self.results["integration"] = self.run_integration_tests()

        mitre_results = self.run_mitre_mapping()
        md_path, json_path = self.generate_report(self.results, mitre_results)
        return self.results, mitre_results, md_path, json_path


def main():
    parser = argparse.ArgumentParser(
        description="Pentest runner (robust paths, non-interactive by default)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("--mode", choices=["quick", "full", "advanced"], default="full")
    parser.add_argument("--interactive", action="store_true", help="Enable prompts (integration tests)")

    args = parser.parse_args()

    runner = CompletePentestRunner(mode=args.mode, interactive=args.interactive)

    try:
        _, _, md_path, json_path = runner.run_complete_suite()
        print("\n" + "=" * 80)
        print("âœ… Pentest completed")
        print(f"ğŸ“„ Markdown report: {md_path}")
        print(f"ğŸ“Š JSON report: {json_path}")
        print("=" * 80 + "\n")
        return 0
    except KeyboardInterrupt:
        print("\nâš ï¸  Interrupted")
        return 1
    except Exception as e:
        logger.error("Fatal error", exc_info=True)
        print(f"\nâŒ Fatal error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
