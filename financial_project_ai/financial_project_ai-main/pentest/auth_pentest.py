# pentest/auth_pentest.py
import jwt
import hashlib
import time
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)


class AuthenticationPentester:
    """Testeur de sécurité pour l'authentification"""
    
    @staticmethod
    def test_password_policy(auth_manager) -> Dict[str, any]:
        """
        Tester la politique de mots de passe
        
        Args:
            auth_manager: Instance de AuthenticationManager
        
        Returns:
            Dict: Résultats des tests
        """
        results = {
            'total_tests': 0,
            'blocked': 0,
            'vulnerabilities': []
        }
        
        weak_passwords = [
            # Trop courts
            ("user1", "Pass1!", "Too short"),
            ("user2", "12345678", "No complexity"),
            
            # Pas de complexité
            ("user3", "passwordpassword", "No uppercase/numbers/special"),
            ("user4", "PASSWORD123456", "No lowercase/special"),
            ("user5", "Password123456", "No special chars"),
            
            # Mots de passe communs
            ("user6", "Password123!", "Common password"),
            ("user7", "Qwerty123456!", "Common password"),
            
            # Contient le username
            ("john", "John123456!", "Contains username"),
            
            # Séquences
            ("user8", "Abc123456789!", "Sequential"),
            ("user9", "Pass123456789!", "Sequential"),
            
            # Caractères répétés
            ("user10", "Paaaassword1!", "Repeated chars"),
        ]
        
        for username, password, reason in weak_passwords:
            results['total_tests'] += 1
            
            from authentication import AuthStatus
            status, message = auth_manager.register_user(username, password)
            
            if status == AuthStatus.WEAK_PASSWORD:
                results['blocked'] += 1
                logger.info(f"✅ Weak password blocked: {reason}")
            else:
                results['vulnerabilities'].append({
                    'username': username,
                    'password': password[:4] + "***",
                    'reason': reason,
                    'severity': 'High'
                })
                logger.warning(f"⚠️ Weak password accepted: {reason}")
        
        results['block_rate'] = (results['blocked'] / results['total_tests']) * 100
        
        return results
    
    @staticmethod
    def test_brute_force_protection(auth_manager) -> Dict[str, any]:
        """
        Tester la protection contre le brute force
        
        Args:
            auth_manager: Instance de AuthenticationManager
        
        Returns:
            Dict: Résultats des tests
        """
        results = {
            'total_tests': 0,
            'lockout_triggered': False,
            'attempts_before_lockout': 0
        }
        
        # Créer un utilisateur de test
        from authentication import AuthStatus
        auth_manager.register_user("bruteforce_test", "ValidPassword123!")
        
        # Tenter plusieurs connexions échouées
        max_attempts = 10
        
        for i in range(max_attempts):
            results['total_tests'] += 1
            
            status, result = auth_manager.login("bruteforce_test", "WrongPassword")
            
            if status == AuthStatus.ACCOUNT_LOCKED:
                results['lockout_triggered'] = True
                results['attempts_before_lockout'] = i + 1
                logger.info(f"✅ Account locked after {i + 1} failed attempts")
                break
        
        if not results['lockout_triggered']:
            results['vulnerability'] = {
                'type': 'no_brute_force_protection',
                'severity': 'Critical',
                'description': f'No account lockout after {max_attempts} failed attempts'
            }
            logger.warning("⚠️ No brute force protection detected")
        
        return results
    
    @staticmethod
    def test_jwt_security(jwt_manager) -> Dict[str, any]:
        """
        Tester la sécurité des tokens JWT
        
        Args:
            jwt_manager: Instance de JWTManager
        
        Returns:
            Dict: Résultats des tests
        """
        results = {
            'total_tests': 0,
            'vulnerabilities': []
        }
        
        # Test 1: Token sans signature (algorithm: none)
        results['total_tests'] += 1
        
        try:
            # Créer un token avec algorithm none
            unsigned_token = jwt.encode(
                {'sub': 'attacker', 'type': 'access'},
                '',
                algorithm='none'
            )
            
            is_valid, payload = jwt_manager.verify_token(unsigned_token)
            
            if is_valid:
                results['vulnerabilities'].append({
                    'type': 'accepts_unsigned_tokens',
                    'severity': 'Critical',
                    'description': 'System accepts tokens with algorithm: none'
                })
                logger.warning("⚠️ CRITICAL: Accepts unsigned JWT tokens")
            else:
                logger.info("✅ Unsigned tokens are rejected")
        except Exception as e:
            logger.info(f"✅ Token verification failed as expected: {e}")
        
        # Test 2: Token expiré
        results['total_tests'] += 1
        
        try:
            # Créer un token avec expiration dans le passé
            import datetime
            expired_payload = {
                'sub': 'testuser',
                'type': 'access',
                'exp': datetime.datetime.utcnow() - datetime.timedelta(hours=1),
                'iat': datetime.datetime.utcnow() - datetime.timedelta(hours=2),
                'jti': 'test123'
            }
            
            expired_token = jwt.encode(
                expired_payload,
                jwt_manager.secret_key,
                algorithm=jwt_manager.algorithm
            )
            
            is_valid, payload = jwt_manager.verify_token(expired_token)
            
            if is_valid:
                results['vulnerabilities'].append({
                    'type': 'accepts_expired_tokens',
                    'severity': 'High',
                    'description': 'System accepts expired JWT tokens'
                })
                logger.warning("⚠️ Expired tokens are accepted")
            else:
                logger.info("✅ Expired tokens are rejected")
        except Exception as e:
            logger.info(f"✅ Expired token rejected: {e}")
        
        # Test 3: Token avec clé faible
        results['total_tests'] += 1
        
        if len(jwt_manager.secret_key) < 32:
            results['vulnerabilities'].append({
                'type': 'weak_jwt_secret',
                'severity': 'Critical',
                'description': f'JWT secret key is too short: {len(jwt_manager.secret_key)} chars'
            })
            logger.warning(f"⚠️ JWT secret is too short: {len(jwt_manager.secret_key)} chars")
        else:
            logger.info("✅ JWT secret key length is adequate")
        
        # Test 4: Token manipulation
        results['total_tests'] += 1
        
        try:
            # Créer un token valide
            token = jwt_manager.create_access_token('testuser')
            
            # Tenter de modifier le payload
            parts = token.split('.')
            if len(parts) == 3:
                import base64
                import json
                
                # Décoder le payload
                padding = '=' * (4 - len(parts[1]) % 4)
                payload_bytes = base64.urlsafe_b64decode(parts[1] + padding)
                payload = json.loads(payload_bytes)
                
                # Modifier le payload
                payload['sub'] = 'admin'
                
                # Réencoder
                modified_payload = base64.urlsafe_b64encode(
                    json.dumps(payload).encode()
                ).decode().rstrip('=')
                
                # Reconstruire le token
                modified_token = f"{parts[0]}.{modified_payload}.{parts[2]}"
                
                # Vérifier
                is_valid, _ = jwt_manager.verify_token(modified_token)
                
                if is_valid:
                    results['vulnerabilities'].append({
                        'type': 'token_manipulation_possible',
                        'severity': 'Critical',
                        'description': 'Modified tokens are accepted'
                    })
                    logger.warning("⚠️ CRITICAL: Token manipulation is possible")
                else:
                    logger.info("✅ Token manipulation is detected")
        except Exception as e:
            logger.info(f"✅ Token manipulation prevented: {e}")
        
        return results
    
    @staticmethod
    def test_mfa_bypass(auth_manager) -> Dict[str, any]:
        """
        Tester le contournement de MFA
        
        Args:
            auth_manager: Instance de AuthenticationManager
        
        Returns:
            Dict: Résultats des tests
        """
        results = {
            'total_tests': 0,
            'vulnerabilities': []
        }
        
        # Créer un utilisateur avec MFA
        from authentication import AuthStatus
        auth_manager.register_user("mfa_test_user", "ValidPassword123!")
        auth_manager.enable_mfa("mfa_test_user")
        
        # Test 1: Connexion sans code MFA
        results['total_tests'] += 1
        
        status, result = auth_manager.login("mfa_test_user", "ValidPassword123!")
        
        if status == AuthStatus.SUCCESS:
            results['vulnerabilities'].append({
                'type': 'mfa_bypass_no_code',
                'severity': 'Critical',
                'description': 'MFA can be bypassed without providing a code'
            })
            logger.warning("⚠️ CRITICAL: MFA bypass possible")
        elif status == AuthStatus.MFA_REQUIRED:
            logger.info("✅ MFA is properly enforced")
        
        # Test 2: Code MFA invalide
        results['total_tests'] += 1
        
        status, result = auth_manager.login("mfa_test_user", "ValidPassword123!", "000000")
        
        if status == AuthStatus.SUCCESS:
            results['vulnerabilities'].append({
                'type': 'accepts_invalid_mfa',
                'severity': 'Critical',
                'description': 'System accepts invalid MFA codes'
            })
            logger.warning("⚠️ Invalid MFA code accepted")
        else:
            logger.info("✅ Invalid MFA codes are rejected")
        
        return results
    
    @staticmethod
    def test_session_security(session_manager) -> Dict[str, any]:
        """
        Tester la sécurité des sessions
        
        Args:
            session_manager: Instance de SessionManager
        
        Returns:
            Dict: Résultats des tests
        """
        results = {
            'total_tests': 0,
            'vulnerabilities': []
        }
        
        # Test 1: Session fixation
        results['total_tests'] += 1
        
        # Créer une session
        session_id = session_manager.create_session("testuser", "jti123")
        
        # Vérifier si l'ID de session est prévisible
        session_id2 = session_manager.create_session("testuser2", "jti456")
        
        # Analyser l'entropie
        if len(session_id) < 32:
            results['vulnerabilities'].append({
                'type': 'weak_session_id',
                'severity': 'High',
                'description': f'Session ID is too short: {len(session_id)} chars'
            })
            logger.warning(f"⚠️ Session ID is too short: {len(session_id)}")
        else:
            logger.info("✅ Session ID length is adequate")
        
        # Test 2: Vérifier l'invalidation des sessions
        results['total_tests'] += 1
        
        # Révoquer la session
        session_manager.revoke_session(session_id)
        
        # Essayer de récupérer la session révoquée
        revoked_session = session_manager.get_session(session_id)
        
        if revoked_session is not None:
            results['vulnerabilities'].append({
                'type': 'session_not_invalidated',
                'severity': 'High',
                'description': 'Revoked sessions can still be used'
            })
            logger.warning("⚠️ Revoked sessions are not properly invalidated")
        else:
            logger.info("✅ Session revocation works correctly")
        
        return results