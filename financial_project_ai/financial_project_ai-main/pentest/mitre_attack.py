# pentest/mitre_attack.py
from typing import Dict, List
from dataclasses import dataclass
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MITRETactic(Enum):
    """Tactiques MITRE ATT&CK"""
    RECONNAISSANCE = "Reconnaissance"
    RESOURCE_DEVELOPMENT = "Resource Development"
    INITIAL_ACCESS = "Initial Access"
    EXECUTION = "Execution"
    PERSISTENCE = "Persistence"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    DEFENSE_EVASION = "Defense Evasion"
    CREDENTIAL_ACCESS = "Credential Access"
    DISCOVERY = "Discovery"
    LATERAL_MOVEMENT = "Lateral Movement"
    COLLECTION = "Collection"
    EXFILTRATION = "Exfiltration"
    IMPACT = "Impact"


@dataclass
class MITRETechnique:
    """Technique MITRE ATT&CK"""
    id: str
    name: str
    tactic: MITRETactic
    description: str
    test_implemented: bool
    mitigated: bool
    mitigation_notes: str


class MITREAttackMapper:
    """Mapper les tests de sécurité au framework MITRE ATT&CK"""
    
    # Techniques pertinentes pour les applications IA/LLM
    TECHNIQUES = [
        # T1190 - Exploit Public-Facing Application
        MITRETechnique(
            id="T1190",
            name="Exploit Public-Facing Application",
            tactic=MITRETactic.INITIAL_ACCESS,
            description="Exploit des vulnérabilités dans l'application web Gradio",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Input validation, sanitization, CSRF protection"
        ),
        
        # T1059 - Command and Scripting Interpreter
        MITRETechnique(
            id="T1059",
            name="Command and Scripting Interpreter",
            tactic=MITRETactic.EXECUTION,
            description="Injection de commandes via les entrées utilisateur",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Command injection filters, input validation"
        ),
        
        # T1557 - Adversary-in-the-Middle
        MITRETechnique(
            id="T1557",
            name="Adversary-in-the-Middle",
            tactic=MITRETactic.CREDENTIAL_ACCESS,
            description="Interception du trafic pour voler les tokens JWT",
            test_implemented=False,
            mitigated=True,
            mitigation_notes="HTTPS required, secure token transmission"
        ),
        
        # T1110 - Brute Force
        MITRETechnique(
            id="T1110",
            name="Brute Force",
            tactic=MITRETactic.CREDENTIAL_ACCESS,
            description="Attaques par force brute sur l'authentification",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Account lockout after 5 failed attempts, 30min cooldown"
        ),
        
        # T1078 - Valid Accounts
        MITRETechnique(
            id="T1078",
            name="Valid Accounts",
            tactic=MITRETactic.PERSISTENCE,
            description="Utilisation de comptes compromis",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="MFA required, session monitoring, token expiration"
        ),
        
        # T1212 - Exploitation for Credential Access
        MITRETechnique(
            id="T1212",
            name="Exploitation for Credential Access",
            tactic=MITRETactic.CREDENTIAL_ACCESS,
            description="Vol de credentials via exploitation",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Passwords hashed with PBKDF2, no plaintext storage"
        ),
        
        # T1056 - Input Capture
        MITRETechnique(
            id="T1056",
            name="Input Capture",
            tactic=MITRETactic.COLLECTION,
            description="Capture des entrées utilisateur (keylogging)",
            test_implemented=False,
            mitigated=True,
            mitigation_notes="Client-side protection recommended"
        ),
        
        # T1565 - Data Manipulation
        MITRETechnique(
            id="T1565",
            name="Data Manipulation",
            tactic=MITRETactic.IMPACT,
            description="Manipulation des données financières en cache",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="HMAC integrity checks, encrypted cache, file permissions"
        ),
        
        # T1567 - Exfiltration Over Web Service
        MITRETechnique(
            id="T1567",
            name="Exfiltration Over Web Service",
            tactic=MITRETactic.EXFILTRATION,
            description="Exfiltration de données via l'API",
            test_implemented=False,
            mitigated=True,
            mitigation_notes="API rate limiting, data minimization, audit logging"
        ),
        
        # T1040 - Network Sniffing
        MITRETechnique(
            id="T1040",
            name="Network Sniffing",
            tactic=MITRETactic.CREDENTIAL_ACCESS,
            description="Sniffing du trafic réseau",
            test_implemented=False,
            mitigated=True,
            mitigation_notes="HTTPS/TLS encryption required"
        ),
        
        # Techniques spécifiques aux LLM
        MITRETechnique(
            id="LLM01",
            name="Prompt Injection",
            tactic=MITRETactic.INITIAL_ACCESS,
            description="Injection de prompts malveillants pour contourner les contrôles",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Prompt injection detection, input sanitization, context isolation"
        ),
        
        MITRETechnique(
            id="LLM02",
            name="Insecure Output Handling",
            tactic=MITRETactic.EXECUTION,
            description="Exploitation des sorties non validées du LLM",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Output sanitization, HTML escaping, XSS prevention"
        ),
        
        MITRETechnique(
            id="LLM06",
            name="Sensitive Information Disclosure",
            tactic=MITRETactic.COLLECTION,
            description="Extraction d'informations sensibles via le LLM",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="PII detection and redaction, no secrets in prompts"
        ),
        
        MITRETechnique(
            id="LLM08",
            name="Excessive Agency",
            tactic=MITRETactic.IMPACT,
            description="LLM effectue des actions non autorisées",
            test_implemented=True,
            mitigated=True,
            mitigation_notes="Strict tool access control, validation of all actions"
        ),
    ]
    
    @classmethod
    def get_coverage_report(cls) -> Dict[str, any]:
        """
        Générer un rapport de couverture MITRE ATT&CK
        
        Returns:
            Dict: Rapport de couverture
        """
        tactics_coverage = {}
        
        for technique in cls.TECHNIQUES:
            tactic_name = technique.tactic.value
            
            if tactic_name not in tactics_coverage:
                tactics_coverage[tactic_name] = {
                    'total': 0,
                    'tested': 0,
                    'mitigated': 0,
                    'techniques': []
                }
            
            tactics_coverage[tactic_name]['total'] += 1
            
            if technique.test_implemented:
                tactics_coverage[tactic_name]['tested'] += 1
            
            if technique.mitigated:
                tactics_coverage[tactic_name]['mitigated'] += 1
            
            tactics_coverage[tactic_name]['techniques'].append({
                'id': technique.id,
                'name': technique.name,
                'tested': technique.test_implemented,
                'mitigated': technique.mitigated,
                'mitigation_notes': technique.mitigation_notes
            })
        
        # Calculer les pourcentages
        for tactic in tactics_coverage.values():
            tactic['test_coverage'] = (tactic['tested'] / tactic['total']) * 100
            tactic['mitigation_coverage'] = (tactic['mitigated'] / tactic['total']) * 100
        
        return {
            'tactics': tactics_coverage,
            'overall': {
                'total_techniques': len(cls.TECHNIQUES),
                'tested': sum(1 for t in cls.TECHNIQUES if t.test_implemented),
                'mitigated': sum(1 for t in cls.TECHNIQUES if t.mitigated),
                'test_coverage': (sum(1 for t in cls.TECHNIQUES if t.test_implemented) / len(cls.TECHNIQUES)) * 100,
                'mitigation_coverage': (sum(1 for t in cls.TECHNIQUES if t.mitigated) / len(cls.TECHNIQUES)) * 100
            }
        }
    
    @classmethod
    def get_technique_by_id(cls, technique_id: str) -> MITRETechnique:
        """
        Récupérer une technique par son ID
        
        Args:
            technique_id: ID de la technique
        
        Returns:
            MITRETechnique: Technique correspondante
        """
        for technique in cls.TECHNIQUES:
            if technique.id == technique_id:
                return technique
        return None
    
    @classmethod
    def get_unmitgated_techniques(cls) -> List[MITRETechnique]:
        """
        Obtenir les techniques non mitigées
        
        Returns:
            List[MITRETechnique]: Techniques non mitigées
        """
        return [t for t in cls.TECHNIQUES if not t.mitigated]
    
    @classmethod
    def get_untested_techniques(cls) -> List[MITRETechnique]:
        """
        Obtenir les techniques non testées
        
        Returns:
            List[MITRETechnique]: Techniques non testées
        """
        return [t for t in cls.TECHNIQUES if not t.test_implemented]